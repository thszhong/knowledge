23种设计模式来自于大神GOF的总结，书名 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素）。
设计模式的核心思路是
* 对接口编程，不对实现编程
* 优先考虑对象组合，而不是继承 （Why？）

关键点
* 在合适的场景使用，过渡使用设计模式会提升整体架构的复杂度
* 弄清楚设计模式之间的差别


| 类型 | 设计模式 |
| - | - |
| 创建型 | 工厂 Factory 、抽象工厂Abstract Factory、建造者builder、单例SingleInstance、原型ProtoType | 
| 结构型 | 组合Compsite、门面Facade、 适配器Adapter、代理Proxy 、装饰器Decorator、桥接Bridge、亨元FlyWheel | 
| 行为型 | 责任链Chain、命令模式Command、策略模式Stragetory、解释器Interceptor、迭代器Iterator、中介者Mediator、备忘录Memento、观察者Observer、状态State、、模板Template、访问者Visitor |
| 其他 | 过滤器Filter、 |

# 创建型

- 工厂模式，将对象的创建和使用进行分离。
- 抽象工厂，解决产品族的一致性
- 建造者，解决参数特别多的问题，比如构造http请求
- 单例模式，保障对象的唯一性，比如数据库连接
- 原型模式，解决复杂对象重复构造成本高的问题，比如常用的clone。注意这里的深拷贝和浅拷贝。

# 结构型

- 适配器、装饰器、代理：适配器侧重修改现有功能、代理侧重现有访问权限控制、装饰器侧重增新功能。
- 组合：？
- 门面：侧重大一统，通常是基础平台的API层；
- 亨元：提升大量轻量级对象的创建效率，比如线程池。 钟叔疑问：为啥这个要归类到结构型，貌似解决的是创建成本。
- 桥接：？

# 行为模式
- 迭代器、责任链：迭代器侧重顺序访问、责任链侧重寻找执行者。责任链、filter可能同时存在。
- 解释器、备忘录：日常场景？
- 命令模式：回调场景，解决调用者的耦合性
- 策略模式：找到对应的处理逻辑，解决可拓展性问题
- 中介者：M*N个耦合，加入中介希望是M+N的耦合，降低系统的耦合，有点像增加一个截面，比如MVC里面的C对M和V进行隔离。
- 观察者：异步执行的基础，数据流驱动的基础。
- 状态模式：存储状态和上下文，在程序设计中属于数据总线
- 模板：定义统一接口
- 访问者：和filter、责任链差别是啥？

# 其他

- 过滤器：统一标准接口。钟叔疑问：这个有啥实际场景？仅仅过滤，和责任链
